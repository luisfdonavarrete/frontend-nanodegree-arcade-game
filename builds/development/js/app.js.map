{
  "version": 3,
  "sources": [
    "node_modules/browser-pack/_prelude.js",
    "app/scripts/app.js",
    "app/scripts/entities/life.js",
    "app/scripts/entities/player.js",
    "app/scripts/entities/sprite.js"
  ],
  "names": [],
  "mappings": "AAAA;ACAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACnzBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AChCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACpMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA",
  "file": "generated.js",
  "sourceRoot": "",
  "sourcesContent": [
    "(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})",
    "'use strict';\n\nvar Player = require('./entities/player.js');\n\nvar player = new Player();\n//\n//\n//\n// var frogger;\n// var player;\n// var map;\n// var allEnemies;\n// var currentLevel = 1;\n// var key;\n// var gems;\n// var score = [];\n// for (var i = 0, stopCondition = Object.keys(gameData).length; i < stopCondition; i++) {\n//     score[i] = 0;\n// }\n// var CANVAS_WITH = 505;\n// var CANVAS_HEIGHT = 606;\n// var allowedKeys = {\n//     37: 'left',\n//     38: 'up',\n//     39: 'right',\n//     40: 'down',\n//     13: 'enter'\n// };\n//\n// var timer = 0;\n//\n// /**\n//  * Represents a Finite State Machine.\n//  * @class FiniteStateMachine\n//  * @constructor\n//  */\n// function FiniteStateMachine() {\n//     this.states = {};\n//     this.currentState = \"\";\n//     this.previousState = \"\";\n// }\n//\n// /**\n//  * Add a new state to the states variable.\n//  * @method addState\n//  * @param {string} stateName - The name of the state.\n//  * @param {object} stateObject - The instance of the state object.\n//  * @param {array} statesAllowed - Array of state names that are allowed to switch.\n//  */\n// FiniteStateMachine.prototype.addState = function (stateName, stateObject, statesAllowed) {\n//     this.states[stateName] = {\n//         \"stateName\": stateName,\n//         \"stateObject\": stateObject,\n//         \"statesAllowed\": statesAllowed\n//     };\n// };\n//\n// /**\n//  * Set the current state\n//  * @method setState\n//  * @param {string} stateName - The name of the state to be set.\n//  */\n// FiniteStateMachine.prototype.setState = function (stateName) {\n//     if (this.currentState === \"\") {\n//         this.currentState = stateName;\n//         this.states[this.currentState].stateObject.enter();\n//         return;\n//     }\n//     if (this.currenState === stateName) {\n//         console.log(\"the actor is already in this state\");\n//         return;\n//     }\n//     if (this.states[this.currentState].statesAllowed.indexOf(stateName) > -1) {\n//         this.states[this.currentState].stateObject.exit();\n//         this.previousState = this.currentState;\n//         this.currentState = stateName;\n//     } else {\n//         console.log(\"you are not allowed to switch to that \" + stateName + \"state being in \" + this.currentState + \"state\");\n//     }\n//     this.states[this.currentState].stateObject.enter();\n// };\n//\n// /**\n//  * Calls the update method of the current state.\n//  * @method update\n//  * @param {number} dt - time delta information.\n//  */\n// FiniteStateMachine.prototype.update = function (dt) {\n//     this.states[this.currentState].stateObject.update(dt);\n// };\n\n//\n\n//\n//\n//\n// /**\n//  * Represents the Frogger Game.\n//  * @class Frogger\n//  * @constructor\n//  */\n// function Frogger() {\n//     this.velocity = 150;\n//     this.finiteStateMachine = new FiniteStateMachine();\n//     this.characters = [\n//             \"images/char-boy.png\",\n//             \"images/char-cat-girl.png\",\n//             \"images/char-horn-girl.png\",\n//             \"images/char-pink-girl.png\",\n//             \"images/char-princess-girl.png\"\n//         ];\n//     /** Define the different states that the game ca be in*/\n//     this.states = {\n//         \"MENU\": \"MENU\",\n//         \"PLAYING\": \"PLAYING\",\n//         \"PAUSED\": \"PAUSED\",\n//         \"LOSING\": \"LOSING\",\n//         \"TRANSITION_LEVEL\": \"TRANSITION_LEVEL\",\n//         \"GAME_OVER\": \"GAME_OVER\",\n//         \"END\": \"END\"\n//     };\n//     this.selectedCharacter = 0;\n//     this.offset = CANVAS_HEIGHT / 2 - 171 / 2;\n//     /** Add the state to the finite state machine instane */\n//     this.finiteStateMachine.addState(this.states.MENU, new MenuState(this), [\"PLAYING\"]);\n//     this.finiteStateMachine.addState(this.states.PLAYING, new PlayingState(this), [\"MENU\", \"PAUSED\", \"LOSING\", \"TRANSITION_LEVEL\"]);\n//     this.finiteStateMachine.addState(this.states.LOSING, new LosingState(this), [\"PLAYING\", \"GAME_OVER\"]);\n//     this.finiteStateMachine.addState(this.states.TRANSITION_LEVEL, new TransitionLevelState(this), [\"PLAYING\", \"END\"]);\n//     this.finiteStateMachine.addState(this.states.GAME_OVER, new GameOverState(this), [\"PLAYING\", \"MENU\"]);\n//     this.finiteStateMachine.addState(this.states.END, new EndGameState(this), [\"MENU\"]);\n//     /** Set the initial sate to MENU */\n//     this.finiteStateMachine.setState(this.states.MENU);\n// }\n//\n// /**\n//  * Calls the update method on the finite state machine\n//  * @method update\n//  * @param {number} dt - time delta informaction\n//  */\n// Frogger.prototype.update = function (dt) {\n//     this.finiteStateMachine.update(dt);\n// };\n//\n// /**\n//  * Event handler for the player input\n//  * @method handleInput\n//  * @param {string} key - string thta indicate the pressed key\n//  */\n// Frogger.prototype.handleInput = function (key) {\n//     switch (key) {\n//     case \"left\":\n//         this.selectedCharacter = (this.selectedCharacter > 0) ? this.selectedCharacter - 1 : this.selectedCharacter;\n//         break;\n//     case \"right\":\n//         this.selectedCharacter = (this.selectedCharacter < this.characters.length - 1) ? this.selectedCharacter + 1 : this.selectedCharacter;\n//         break;\n//     case \"enter\":\n//         this.finiteStateMachine.setState(this.states.PLAYING);\n//         break;\n//     default:\n//         break;\n//     }\n// };\n//\n// /**\n//  * Reset the game, the level, the score, lives, timer.\n//  * @method reset\n//  */\n// Frogger.prototype.reset = function () {\n//     timer = 0;\n//     currentLevel = 1;\n//     player.numOfLives = 5;\n//     for (var i = 0, condition = score.length; i < condition; i++) {\n//         score[i] = 0;\n//     }\n//     player.lives.forEach(function (live) {\n//         live.state = true;\n//     });\n//     start();\n//     this.finiteStateMachine.setState(this.states.MENU);\n// }\n//\n// /**\n//  * Represents a MenuState.\n//  * @class MenuState\n//  * @constructor\n//  * @param {object} actor - the object that has the instance of the finite state machine\n//  */\n// function MenuState(actor) {\n//     this.actor = actor;\n// }\n//\n// /**\n//  * The method gets called when the game enters the state, Add event listener\n//  * @method enter\n//  */\n// MenuState.prototype.enter = function () {\n//     document.addEventListener(\"keyup\", menuEventHandler, false);\n// };\n//\n// /**\n//  * The method called for the finite state machine\n//  * @method update\n//  * @param {number} dt - time delta information\n//  */\n// MenuState.prototype.update = function (dt) {\n//     this.render();\n// };\n//\n// /**\n//  * Render the select character screen\n//  * @method update\n//  */\n// MenuState.prototype.render = function () {\n//     ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height);\n//     renderMap();\n//     ctx.fillStyle = \"black\";\n//     ctx.globalAlpha = 0.5; // Half opacity\n//     ctx.fillRect(0, 50, ctx.canvas.width, ctx.canvas.height - 70);\n//     ctx.globalAlpha = 1;\n//     // Draw the title\n//     ctx.font = \"42px 'Gloria Hallelujah', cursive, Arial, serif\";\n//     ctx.textAlign = \"center\";\n//     ctx.fillStyle = \"white\";\n//     ctx.fillText(\"Choose Your Character\", ctx.canvas.width / 2, 140);\n//     // draw selector image\n//     var self = this.actor;\n//     this.actor.characters.forEach(function (character, row) {\n//         if (self.selectedCharacter == row) {\n//             ctx.drawImage(Resources.get(\"images/Selector.png\"), row * 101, self.offset);\n//         }\n//         ctx.drawImage(Resources.get(character), row * 101, self.offset);\n//     });\n// };\n//\n// /**\n//  * the method gets called before leaving the state, remove the event listener\n//  * @method exit\n//  */\n// MenuState.prototype.exit = function () {\n//     document.removeEventListener(\"keyup\", menuEventHandler, false);\n//     player.setSprite(this.actor.characters[this.actor.selectedCharacter]);\n// };\n//\n// /**\n//  * Represents a PlayingState.\n//  * @class PlayingState\n//  * @constructor\n//  * @param {object} actor - the object that has the finite state machine instance\n//  */\n// function PlayingState(actor) {\n//     this.actor = actor;\n// }\n//\n// /**\n//  * The method gets called when the game enters the state, Add event listener\n//  * @method enter\n//  */\n// PlayingState.prototype.enter = function () {\n//     document.addEventListener(\"keyup\", playingEventHandler, false);\n// };\n//\n// /**\n//  * update the playing state\n//  * @method update\n//  * @param {number} dt - time delta information\n//  */\n// PlayingState.prototype.update = function (dt) {\n//     allEnemies.forEach(function (enemy) {\n//         enemy.update(dt);\n//     });\n//     gems.forEach(function (gem) {\n//         gem.update(dt);\n//     });\n//     key.update(dt);\n//     player.update();\n//     player.checkKey();\n//     player.checkGems();\n//     if (player.checkCollisionEnemies() || player.checkMap()) {\n//         this.actor.finiteStateMachine.setState(this.actor.states.LOSING);\n//     }\n//     if (player.checkLevel()) {\n//         this.actor.finiteStateMachine.setState(this.actor.states.TRANSITION_LEVEL);\n//     }\n//     if (player.getLives() <= 0) {\n//         this.actor.finiteStateMachine.setState(this.actor.states.GAME_OVER);\n//     }\n//     this.render();\n// };\n//\n//\n// /**\n//  * Render the playing state\n//  * @method render\n//  */\n// PlayingState.prototype.render = function () {\n//     ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height);\n//     renderTimeAndScore();\n//     renderMap();\n//     renderEnemies();\n//     renderGems();\n//     player.render();\n//     key.render();\n// };\n//\n// /**\n//  * Exit the playing state, remove event listener\n//  * @method exit\n//  */\n// PlayingState.prototype.exit = function () {\n//     document.removeEventListener(\"keyup\", playingEventHandler, false);\n// };\n//\n// /**\n//  * Represents a LosingState.\n//  * @class LosingState\n//  * @constructor\n//  * @param {object} actor -  the object that has the finite state machine instance\n//  */\n// function LosingState(actor) {\n//     this.actor = actor;\n//     this.path;\n//     this.startPonit;\n//     this.endPoint;\n// }\n//\n// /**\n//  * The method gets called when the game enters the state,\n//  * set the last player position\n//  * set the initial position according to the level\n//  * set the path to move the player\n//  * reset the level: score, key, gems\n//  * @method enter\n//  */\n// LosingState.prototype.enter = function () {\n//     this.startPonit = buildPoint(player.drawX, player.drawY);\n//     this.endPoint = buildPoint(gameData[\"level\" + currentLevel].player_position.x, gameData[\"level\" + currentLevel].player_position.y);\n//     this.path = construcLineEquation(this.startPonit, this.endPoint);\n//     player.key = false;\n//     key.init(\n//         gameData[\"level\" + currentLevel].key.x,\n//         gameData[\"level\" + currentLevel].key.y,\n//         gameData[\"level\" + currentLevel].key.value\n//     );\n//     gems = createGems(gameData[\"level\" + currentLevel].gems);\n//     score[currentLevel - 1] = 0;\n// };\n//\n// /**\n//  * Move the player from the position where he lost to the initial position\n//  * @method update\n//  */\n// LosingState.prototype.update = function (dt) {\n//     if (this.startPonit.x == this.endPoint.x) {\n//         player.drawY = player.drawY + this.actor.velocity * dt;\n//         if (player.drawY >= this.endPoint.y) {\n//             this.actor.finiteStateMachine.setState(this.actor.states.PLAYING);\n//         }\n//     } else if (this.startPonit.y == this.endPoint.y) {\n//         player.drawX = (this.startPonit.x > this.endPoint.x) ? player.drawX - this.actor.velocity * dt : player.drawX + this.actor.velocity * dt;\n//         if (this.startPonit.x > this.endPoint.x && player.drawX <= this.endPoint.x) {\n//             this.actor.finiteStateMachine.setState(this.actor.states.PLAYING);\n//         } else if (this.startPonit.x < this.endPoint.x && player.drawX >= this.endPoint.x) {\n//             this.actor.finiteStateMachine.setState(this.actor.states.PLAYING);\n//         }\n//     } else {\n//         player.drawX = (this.startPonit.x > this.endPoint.x) ? player.drawX - this.actor.velocity * dt : player.drawX + this.actor.velocity * dt;\n//         player.drawY = this.path(player.drawX);\n//         if (this.startPonit.x > this.endPoint.x && player.drawX <= this.endPoint.x) {\n//             this.actor.finiteStateMachine.setState(this.actor.states.PLAYING);\n//         } else if (this.startPonit.x < this.endPoint.x && player.drawX >= this.endPoint.x) {\n//             this.actor.finiteStateMachine.setState(this.actor.states.PLAYING);\n//         }\n//     }\n//     this.render();\n// };\n//\n// /**\n//  * Render the game scenario: map, enemies, gems, player, key, timer and score.\n//  * @method render\n//  */\n// LosingState.prototype.render = function () {\n//     ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height);\n//     renderTimeAndScore();\n//     renderMap();\n//     renderEnemies();\n//     renderGems();\n//     ctx.globalAlpha = 0.7;\n//     player.render();\n//     ctx.globalAlpha = 1;\n//     key.render();\n// }\n//\n//\n// /**\n//  *\n//  * @method exit\n//  */\n// LosingState.prototype.exit = function () {\n//     player.drawX = this.endPoint.x;\n//     player.drawY = this.endPoint.y;\n// };\n//\n// /**\n//  * Represents a TransitionLevelState.\n//  * @class TransitionLevelState\n//  * @constructor\n//  * @param {object} actor -  the object that has the finite state machine instance\n//  */\n// function TransitionLevelState(actor) {\n//     this.actor = actor;\n//     this.time;\n// }\n//\n// /**\n//  * The method gets called when the game enters the state,\n//  * increase the level if is not the laste level.\n//  * @method enter\n//  */\n// TransitionLevelState.prototype.enter = function () {\n//     this.time = 0;\n//     if (currentLevel < Object.keys(gameData).length) {\n//         currentLevel = currentLevel + 1;\n//     } else {\n//         this.actor.finiteStateMachine.setState(this.actor.states.END);\n//     }\n// };\n//\n// /**\n//  * The method called by the finite state machine, wait 2 second before to start the next level\n//  * @method update\n//  */\n// TransitionLevelState.prototype.update = function (dt) {\n//     this.time++;\n//     if (this.time >= 120) {\n//         this.actor.finiteStateMachine.setState(this.actor.states.PLAYING);\n//     }\n//     this.render();\n// };\n//\n// /**\n//  * Render the transition level state.\n//  * @method render\n//  */\n// TransitionLevelState.prototype.render = function () {\n//     ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height);\n//     renderMap();\n//     renderEnemies();\n//     renderGems();\n//     player.render();\n//     key.render();\n//     renderTimeAndScore();\n//     ctx.globalAlpha = 0.5;\n//     ctx.fillStyle = \"black\";\n//     ctx.fillRect(0, ctx.canvas.height / 2 - 50, ctx.canvas.width, 75);\n//     ctx.globalAlpha = 1;\n//     ctx.font = \"36px 'Gloria Hallelujah', cursive, Arial, serif\";\n//     ctx.textAlign = \"center\";\n//     ctx.fillStyle = \"white\";\n//     ctx.fillText(\"Level \" + currentLevel, ctx.canvas.width / 2, ctx.canvas.height / 2);\n// };\n//\n//\n// /**\n//  * Exit the transition level state, start the next level\n//  * @method render\n//  */\n// TransitionLevelState.prototype.exit = function () {\n//     if (currentLevel < Object.keys(gameData).length) {\n//         start();\n//     }\n// };\n//\n// /**\n//  * Represents a GameOverState.\n//  * @class GameOverState\n//  * @constructor\n//  * @param {object} actor -  the object that has the finite state machine instance\n//  */\n// function GameOverState(actor) {\n//     this.actor = actor;\n// }\n//\n// /**\n//  * Add the event listener\n//  * @method enter\n//  */\n// GameOverState.prototype.enter = function () {\n//     document.addEventListener(\"keyup\", gameOverEventHandler, false);\n// };\n//\n// /**\n//  * call the render method of the game over state\n//  * @method update\n//  */\n// GameOverState.prototype.update = function (dt) {\n//     this.render();\n// };\n//\n// /**\n//  * render the game over state\n//  * @method render\n//  */\n// GameOverState.prototype.render = function () {\n//     ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height);\n//     renderMap();\n//     renderEnemies();\n//     renderGems();\n//     renderTimeAndScore();\n//     player.render();\n//     key.render();\n//     ctx.globalAlpha = 0.5;\n//     ctx.fillRect(0, 250, ctx.canvas.width, 100);\n//     ctx.globalAlpha = 1;\n//     ctx.font = \"48px 'Gloria Hallelujah', cursive, Arial, serif\";\n//     ctx.fillStyle = \"white\";\n//     ctx.textAlign = \"center\";\n//     ctx.fillText(\"GAME OVER\", ctx.canvas.width / 2, ctx.canvas.height / 2);\n//     ctx.font = \"18px 'Gloria Hallelujah', cursive, Arial, serif\";\n//     ctx.fillText(\"Press ANY KEY to Continue\", ctx.canvas.width / 2, ctx.canvas.height / 2 + 25);\n// };\n//\n// /**\n//  * REmove the event listener\n//  * @method exit\n//  */\n// GameOverState.prototype.exit = function () {\n//     document.removeEventListener(\"keyup\", gameOverEventHandler, false);\n// };\n//\n// /**\n//  * Represents a EndGameState.\n//  * @class EndGameState\n//  * @constructor\n//  * @param {object} actor -  the object that has the finite state machine instance\n//  */\n// function EndGameState(actor) {\n//     this.actor = actor;\n// }\n//\n// /**\n//  * Add event listener\n//  * @method enter\n//  */\n// EndGameState.prototype.enter = function () {\n//     document.addEventListener(\"keyup\", endGameEventHandler, false);\n// };\n//\n// /**\n//  * call the render method of the end game state\n//  * @method update\n//  */\n// EndGameState.prototype.update = function (dt) {\n//     this.render();\n// };\n//\n//\n// /**\n//  * Render the game over screen\n//  * @method render\n//  */\n// EndGameState.prototype.render = function () {\n//     ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height);\n//     renderMap();\n//     renderEnemies();\n//     renderGems();\n//     renderTimeAndScore();\n//     player.render();\n//     key.render();\n//     ctx.globalAlpha = 0.5;\n//     ctx.fillRect(0, 250, ctx.canvas.width, 100);\n//     ctx.globalAlpha = 1;\n//     ctx.font = \"48px 'Gloria Hallelujah', cursive, Arial, serif\";\n//     ctx.fillStyle = \"white\";\n//     ctx.textAlign = \"center\";\n//     ctx.fillText(\"CONGRATS!!!!\", ctx.canvas.width / 2, ctx.canvas.height / 2);\n//     ctx.font = \"18px 'Gloria Hallelujah', cursive, Arial, serif\";\n//     ctx.fillText(\"Your Score: \" + calculateScore(), ctx.canvas.width / 2, ctx.canvas.height / 2 + 25);\n// };\n//\n// /**\n//  * Remove the event listener\n//  * @method exit\n//  */\n// EndGameState.prototype.exit = function () {\n//     document.removeEventListener(\"keyup\", endGameEventHandler, false);\n// };\n//\n// /* General Functions */\n//\n// /**\n//  * Function event handler for the menu state\n//  * @param {event} - event object\n//  */\n// var menuEventHandler = function (e) {\n//     frogger.handleInput(allowedKeys[e.keyCode]);\n// };\n//\n// /**\n//  * Function event handler for the playing state\n//  * @param {event} - event object\n//  */\n// var playingEventHandler = function (e) {\n//     player.handleInput(allowedKeys[e.keyCode]);\n// };\n//\n// /**\n//  * Function event handler for the game over state\n//  * @param {event} - event object\n//  */\n// var gameOverEventHandler = function (e) {\n//     frogger.reset();\n// };\n//\n// /**\n//  * Function event handler for the end game state\n//  * @param {event} - event object\n//  */\n// var endGameEventHandler = function (e) {\n//     frogger.reset();\n// };\n//\n// /**\n//  * Define the line equation between to points.\n//  * @params {object} p - and object that represent a point (p.x, p.y)on the canvas\n//  * @params {object} q - and object that represent a point (q.x, q.y) on the canvas\n//  * @return {function} the line equation\n//  */\n// function construcLineEquation(p, q) {\n//     return function (x) {\n//         return (((x - p.x) * (q.y - p.y)) / (q.x - p.x)) + p.y;\n//     };\n// }\n//\n// /**\n//  * Calculate the score by reducing the score array\n//  * @return {number}\n//  */\n// function calculateScore() {\n//     var total = score.reduce(function (a, b) {\n//         return a + b;\n//     });\n//     return total.toFixed(2);\n// }\n//\n// /**\n//  * Create a two dimension matriz that represent the map of the current level\n//  * @param {array} levels - array of string that represent the map and different type of tile\n//  * @return {array}\n// */\n// function createMap(levels) {\n//     var mapMatriz = [];\n//     levels.forEach(function (row, i) {\n//         var mapRow = [];\n//         row.split(\"\").forEach(function (tile, j) {\n//             switch (tile) {\n//             case \"W\":\n//                 mapRow.push(new WaterTile(j, i, \"images/water-block.png\"));\n//                 break;\n//             case \"G\":\n//                 mapRow.push(new GrassTile(j, i, \"images/grass-block.png\"));\n//                 break;\n//             case \"S\":\n//                 mapRow.push(new StoneTile(j, i, \"images/stone-block.png\"));\n//                 break;\n//             case \"D\":\n//                 mapRow.push(new Door(j, i, \"images/stone-block.png\"));\n//                 break;\n//             }\n//         });\n//         mapMatriz.push(mapRow);\n//     });\n//     return mapMatriz;\n// }\n//\n// /**\n//  * Start the current level and set the initial position of the different object\n//  */\n// function start() {\n//     map = createMap(gameData[\"level\" + currentLevel].map);\n//     allEnemies = createEnemies(gameData[\"level\" + currentLevel].enemies);\n//     gems = createGems(gameData[\"level\" + currentLevel].gems);\n//     player = (player) ? player : new Player();\n//     player.init(gameData[\"level\" + currentLevel].player_position);\n//     key = new Key(\n//         gameData[\"level\" + currentLevel].key.x,\n//         gameData[\"level\" + currentLevel].key.y,\n//         gameData[\"level\" + currentLevel].key.value\n//     );\n//     frogger = (frogger) ? frogger : new Frogger();\n// }\n//\n// /**\n//  * Calute the distance between two point on the canvas\n//  * @param {object} p - an object that represent a point on the canvas (p.x, p.y)\n//  * @param {object} q - an object that represent a point on the canvas (q.x, q.y)\n//  */\n// function distanceTwoPoint(p, q) {\n//     return Math.sqrt(Math.pow((p.x - q.x), 2) + Math.pow((p.y - q.y), 2));\n// }\n//\n// /**\n//  * create the gem objects according to the level\n//  */\n// function createGems(data) {\n//     var gems = [];\n//     data.forEach(function (gem) {\n//         gems.push(new Gem(gem.x, gem.y, gem.sprite, gem.time, gem.value));\n//     });\n//     return gems;\n// }\n//\n// /**\n//  * create the enemie objects according to the level\n//  */\n// function createEnemies(data) {\n//     var allEnemies = [];\n//     data.forEach(function (enemy) {\n//         var aux = new Enemy(enemy.x, enemy.y, enemy.velocity);\n//         allEnemies.push(aux);\n//     });\n//     return allEnemies;\n// }\n//\n// /**\n//  * create the gems object according to the level\n//  * @param {number} x - the x coordinate of the point\n//  * @param {number} y - the y coordinate of the point\n//  * @return {object} - retunt an object of the form {\"x\": x, \"y\": y};\n//  */\n// function buildPoint(x, y) {\n//     return {\n//         \"x\": x,\n//         \"y\": y\n//     };\n// }\n//\n// /**\n//  * Convert a range in a range to another range\n//  * @param {number} rangeStart - the minimum value of the range we want to convert from\n//  * @param {number} rangeEnd -  the maximu value of the range we want to convert from\n//  * @param {number} newRangeStart - the minimum value of the range we want to convert\n//  * @param {number} newRangeEnd - the maximum value of the range we want to convert\n//  * @param {number} value - the value we want to convert\n//  * $return {number}\n//  */\n// function convertRange(rangeStart, rangeEnd, newRangeStart, newRangeEnd, value) {\n//     var scale = (newRangeEnd - newRangeStart) / (rangeEnd - rangeStart);\n//     return (value * scale) + newRangeStart;\n// }\n//\n// /** .\n//  * @param {object} object - the player object\n//  * @param {number} x - the x coordinate on tha canvas\n//  * @param {number} y - the y coordinate on tha canvas\n//  * @return {bool}\n//  */\n// function outOfbound(object, x, y) {\n//     var newBottomY = y + object.height;\n//     var newTopY = y;\n//     var newRightX = x + object.width;\n//     var newLeftX = x;\n//     var topLimit = 48;\n//     var bottomLimit = 548;\n//     var rightLimit = ctx.canvas.width;\n//     var leftLimit = 0;\n//     return newBottomY > bottomLimit ||\n//         newTopY < topLimit ||\n//         newLeftX < leftLimit ||\n//         newRightX > rightLimit;\n// }\n//\n// /**\n//  * interate over the enenies array to draw them on the canvas\n// */\n// function renderEnemies() {\n//     allEnemies.forEach(function (enemy) {\n//         enemy.render();\n//     });\n// }\n//\n// /**\n//  * interate over the map array to draw it on the canvas\n// */\n// function renderMap() {\n//     map.forEach(function (row) {\n//         row.forEach(function (tile) {\n//             tile.render();\n//         });\n//     });\n// }\n//\n// /**\n//  * interate over the gems array to draw them on the canvas\n// */\n// function renderGems() {\n//     gems.forEach(function (gem) {\n//         gem.render();\n//     });\n// }\n//\n// /**\n//  * render the timer and the game score\n// */\n// function renderTimeAndScore() {\n//     ctx.font = \"18px 'Gloria Hallelujah', cursive, Arial, serif\";\n//     ctx.textAlign = \"right\";\n//     ctx.fillStyle = \"black\";\n//     ctx.fillText(\"Score: \", ctx.canvas.width / 2, 45);\n//     ctx.fillText(calculateScore() + \"pts.\", ctx.canvas.width / 2 + 85, 45);\n//     if (frogger.finiteStateMachine.currentState == frogger.states.PLAYING) {\n//         timer = timer + 1;\n//     }\n//     ctx.fillText(\"Level: \" + currentLevel, ctx.canvas.width, 25);\n//     ctx.textAlign = \"center\";\n//     ctx.fillText(\"Time: \" + parseInt(timer / 60), ctx.canvas.width / 2, 25);\n// }\n//\n// start();\n",
    "'use strict';\n\nvar Sprite = require('./sprite.js');\n/**\n * Represents a Live.\n * @class Live\n * @constructor\n */\nfunction Life(x, y) {\n  Sprite.call(this, \"images/heart.png\", 0, 45, x, y, 101, 100);\n  this.scaleWidth = 25;\n  this.scaleHeight = this.scaleWidth / (this.width / this.height);\n  this.state = true;\n}\n\nLife.prototype = Object.create(Sprite.prototype);\nLife.prototype.constructor = Life;\n/**\n * Render the image\n * @method setSprite\n */\nLife.prototype.render = function () {\n    ctx.drawImage(Resources.get(this.sprite), this.srcX, this.srcY, this.width, this.height, this.drawX, this.drawY, this.scaleWidth, this.scaleHeight);\n    if (!this.state) {\n        ctx.beginPath();\n        ctx.lineWidth = 2;\n        ctx.moveTo(this.drawX + this.scaleWidth, this.drawY);\n        ctx.lineTo(this.drawX + 4, this.drawY + this.scaleHeight - 4);\n        ctx.stroke();\n    }\n};\nmodule.exports = Life;\n",
    "'use strict';\n\nvar Sprite = require('./sprite');\nvar Life = require('./life');\n/**\n * Represents a Player.\n * @class Player\n * @constructor\n */\nfunction Player() {\n  Sprite.call(this, \"images/char-boy.png\", 0, 63, 0, 0, 101, 83);\n  this.key = null;\n  this.numOfLives = 5;\n  this.lifes = [];\n  for (var i = 0; i < this.numOfLives; i++) {\n      this.lifes.push(new Life(25 * i, 25));\n  }\n}\nPlayer.prototype = Object.create(Sprite.prototype);\nPlayer.prototype.constructor = Player;\n/**\n * Update the center point of the player\n * @method update\n */\nPlayer.prototype.update = function () {\n    this.centerX = this.drawX + (this.width * 0.5);\n    this.centerY = this.drawY + (this.height * 0.5);\n};\n/**\n * set the position player to the initial position.\n * @method init\n */\nPlayer.prototype.init = function (initialPosition) {\n    this.drawX = initialPosition.x;\n    this.drawY = initialPosition.y;\n    this.centerX = this.drawX + (this.width * 0.5);\n    this.centerY = this.drawY + (this.height * 0.5);\n    this.key = false;\n};\n/**\n * Render the player and the calls the render method on the lives objets.\n * @method render\n */\nPlayer.prototype.render = function () {\n    ctx.drawImage(Resources.get(this.sprite), this.srcX, this.srcY, this.width, this.height, this.drawX, this.drawY, this.width, this.height);\n    ctx.globalAlpha = 1;\n    this.lives.forEach(function (live) {\n        live.render();\n    });\n};\n/**\n * Verify if the player is allowed to move to the next position.\n * @method checkMovement\n * @param {string} e - string that indicate the key that was pressed\n */\nPlayer.prototype.checkMovement = function (e) {\n    var newDrawX = this.drawX;\n    var newDrawY = this.drawY;\n    switch (e) {\n    case \"left\":\n        newDrawX -= this.width;\n        break;\n    case \"right\":\n        newDrawX += this.width;\n        break;\n    case \"down\":\n        newDrawY += this.height;\n        break;\n    case \"up\":\n        newDrawY -= this.height;\n        break;\n    }\n    if (!outOfbound(this, newDrawX, newDrawY) && this.checkCondicion(newDrawX, newDrawY)) {\n        this.drawX = newDrawX;\n        this.drawY = newDrawY;\n    }\n};\n/**\n * Verify if the player collide with the key\n * @method checkKey\n */\nPlayer.prototype.checkKey = function () {\n    if (!this.key) {\n        var p = buildPoint(this.centerX, this.centerY);\n        var q = buildPoint(key.centerX, key.centerY);\n        if (distanceTwoPoint(p, q) < (this.width * 0.5)) {\n            player.key = true;\n            score[currentLevel - 1] += key.value;\n        }\n    }\n};\n/**\n * Vefirify if the player collide with a enemy\n * @method checkCollisionEnemies\n * @return {bool} true if the player collide with a enemy\n */\nPlayer.prototype.checkCollisionEnemies = function () {\n    var self = this;\n    var result = false;\n    allEnemies.forEach(function (enemy) {\n        var p = buildPoint(enemy.centerX, enemy.centerY);\n        var q = buildPoint(self.centerX, self.centerY);\n        if (parseInt(p.y / 83) === parseInt(q.y / 83) && distanceTwoPoint(p, q) < (self.width * 0.81)) {\n            if (self.numOfLives > 0) {\n                self.lives[self.numOfLives - 1].state = false;\n                self.numOfLives--;\n            }\n            result = !result;\n        }\n    });\n    return result;\n};\n/**\n * Retrives the number of lifes\n * @method getLives\n * @return {number} num of active lifes\n */\nPlayer.prototype.getLives = function () {\n    var total = this.lives.reduce(function (a, b) {\n        return (b.state) ? a + 1 : a;\n    }, 0);\n    return total;\n};\n/**\n * Verify if the player collide with a gen in that case the gem is removed.\n * @method checkGems\n */\nPlayer.prototype.checkGems = function () {\n    var self = this;\n    gems.forEach(function (gem, i) {\n        if (gem.time > 0) {\n            var p = buildPoint(gem.centerX, gem.centerY);\n            var q = buildPoint(self.centerX, self.centerY);\n            if (parseInt(p.y / 83) === parseInt(q.y / 83) && distanceTwoPoint(p, q) < (self.width * 0.75)) {\n                score[currentLevel - 1] += gem.value;\n                gems.splice(i, 1);\n                return;\n            }\n        }\n    });\n};\n/**\n * Verify if the player satisfy the condition the go up a level\n * @method checkCondicion\n */\nPlayer.prototype.checkCondicion = function (newDrawX, newDrawY) {\n    var row = parseInt(newDrawY / this.height);\n    var column = parseInt(newDrawX / this.width);\n    if (gameData[\"level\" + currentLevel].end_position.x === row && gameData[\"level\" + currentLevel].end_position.y === column) {\n        return this.key\n    } else {\n        return true;\n    }\n};\n/**\n * Retrives if the player fall down in a water tile\n * @method checkMap\n * @return {bool}\n */\nPlayer.prototype.checkMap = function () {\n    var row = parseInt(this.drawY / this.height);\n    var column = parseInt(this.drawX / this.width);\n    var mapRow = map[row];\n    var mapColumn = mapRow[column];\n    if (mapColumn instanceof WaterTile && this.numOfLives > 0) {\n        this.lives[this.numOfLives - 1].state = false;\n        this.numOfLives--;\n    }\n    return mapColumn instanceof WaterTile;\n};\n/**\n * Check if the player is on the end position of the level.\n * @method checkLevel\n * @return {bool}\n */\nPlayer.prototype.checkLevel = function () {\n    var p = buildPoint(parseInt(this.drawY / 83), parseInt(this.drawX / 83));\n    var q = buildPoint(gameData[\"level\" + currentLevel].end_position.x, gameData[\"level\" + currentLevel].end_position.y);\n    return p.x == q.x &&\n        p.y == q.y;\n};\n/**\n * Event handler for the player input\n * @method handleInput\n */\nPlayer.prototype.handleInput = function (e) {\n    this.checkMovement(e);\n};\n/**\n * Set the image character of the player\n * @method setSprite\n */\nPlayer.prototype.setSprite = function (sprite) {\n    this.sprite = sprite;\n}\nmodule.exports = Player;\n",
    "'use strict';\n\n/**\n * Represents a sprite. All objects are going to inherent from it.\n * @class Sprite\n * @constructor\n */\nfunction Sprite(sprite, srcX, srcY, drawX, drawY, width, height) {\n    this.sprite = sprite;\n    this.srcX = srcX;\n    this.srcY = srcY;\n    this.drawX = drawX;\n    this.drawY = drawY;\n    this.width = width;\n    this.height = height;\n    this.centerX = this.drawX + (this.width * 0.5);\n    this.centerY = this.drawY + (this.height * 0.5);\n}\nmodule.exports = Sprite;\n"
  ]
}